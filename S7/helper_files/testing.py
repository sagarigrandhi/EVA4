# -*- coding: utf-8 -*-
"""testing.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1JilROXmakS6Tiy2Kl0UGa7ehQ8mnpH6G
"""

import torch
import torch.nn as nn 
import torch.nn.functional as F

def test(model, 
         device, 
         test_loader, 
         test_loss, 
         test_accuracy, 
         classes,
         misclassified, 
         criterion = nn.CrossEntropyLoss(),
         misclassified_num=25):
  '''
  Function to test the defined model on the test set.

  :param model: (class), defined CNN model
  :param device: (class), either CUDA or CPU
  :param test_loader: (class), dataloader for the test data
  :param test_loss: (list), list of losses accumulated per epoch during testing
  :param test_accuracy: (list), list of accuracies accumulated per epoch during testing
  :param classes: (tuple), tuple of class names for the images
  :param misclassified: (list), list of misclassified images
  :param criterion: (function), objective function to minimize
  :param misclassified_num: (int), threshold for the number of misclassified images
  '''
  model.eval()
  running_loss = 0.0
  correct = 0
  total = 0
  
  with torch.no_grad():
    for batch_idx, (data, target) in enumerate(test_loader):
      # Get samples
      inputs, labels = data.to(device), target.to(device)
      
      # Forward pass
      output = model(inputs)
      
      # Calculate the loss
      loss = criterion(output, labels) 
      running_loss += loss.item()
      
      # Predict
      _, pred = torch.max(output.data, 1)
      correct += (pred == labels).sum().item()
      total += labels.size(0)

      # Get misclassified images
      if len(misclassified) < misclassified_num:
        for idx in range(data.shape[0]):
          if pred[idx] != target[idx]:
            misclassified.append([data[idx], classes[pred[idx]], classes[target[idx]]])
            if len(misclassified) == misclassified_num:
              break
  
  # Test loss and accuracy 
  test_loss.append(running_loss/len(test_loader))
  test_accuracy.append(100 * (correct/total))
  print(f'\nTest Loss : {test_loss[-1]:.3f}, Test Accuracy : {correct}/{total} ({test_accuracy[-1]:.2f}%)\n')